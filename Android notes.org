*** Binder理解
    - 优势有哪些？
      1. 性能角度：Binder数据拷贝只有一次，依靠内存映射mmap，将内核缓冲区映射到接收进程地址空间，性能仅次于共享内存
      2. 稳定性角度：基于C/S架构，结构清晰，稳定性好
    - 原理简述
      1. 通过ServiceManager获取代理对象，其实是以ServiceManagerProxy(BpBinder(0)) --> Binder driver --> ServiceManager --> handle --> BpBinder(handle)
      2. 调用服务接口其实是代理对象的mRemote(BpBinder) --> Binder driver --> system_server(服务实现者) --> 返回结果
    
*** ActivityManagerService的理解
    1. 负责activity、service、app进程控制
    2. 当需要在新的进程中启动的activity或者service时，AMS会创建新的app进程(startProcessLocked->Process.start-> ZygoteProcess.zygoteSendArgsAndGetResult(socket通信Zygote进程)->ZygoteInit.main->ZygoteServer.runSelectLoop-> ZygoteConnection.runOnce->Zygote.forkAndSpecialize->ZygoteInit.zygoteInit->ZygoteInit.nativeZygoteInit(init Binder)->RuntimeInit.invokeStaticMain)
    3. 创建app进程需完成两项工作(https://blog.csdn.net/luoshengyang/article/details/6747696)：
       - 初始化binder
       - 调用ActivityThread.main函数
*** Activity启动过程 
    1. Launcher调用Instrumentation.execStartActivity
    2. ActivityThread.handleLaunchActivity->performLaunchActivity，创建activity实例，->activity.attach，attach中创建PhoneWindow，->activity.onCreate->PhoneWindow.installDecor(setContentView)
    3. ->ActivityThread.handleResumeActivity->activity.onResume->WindowManagerGlobal.addView->创建ViewRootImpl->ViewRootImpl.setView->ViewRootImpl.requestLayout
*** Handler、Looper、MessageQueue
    1. Looper.loop()为何不会卡死主线程？
       - Looper.loop()->MessageQueue.next()->MessageQueue.nativePollOnce()->Looper::pollInner()(cpp)->epoll_wait
       - 利用了pipe/epoll机制，当MessageQueue.enqueMessage时若处于block状态会调用nativeWake->Looper::wake->write data to eventFd->epoll_wait unblocked
    2. MessageQueue.postSyncBarrier 当设置了障碍后，队列中的同步消息会停止执行，直到removeSyncBarrier被调用，默认情况下，消息都是同步的
*** Zygote进程启动过程
    1. init进程加载init.rc文件，启动app_process --zygote --start-system-server, code base on android oreo 8.0.0_r4
    2. in /frameworks/base/cmds/app_process/app_main.cpp::main()  --> AndroidRuntime::start("com.android.internal.os.ZygoteInit", true)
    3. in /frameworks/base/core/jni/AndroidRuntime.cpp --> startVm() --> startReg()(注册jni方法) --> env->callStaticVoidMethod(), init android runtime, start java virtual machine and invoke ZygoteInit class's main method
    4. in /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java --> ZygoteServer.registerZygoteSocket() --> startSystemServer() --> ZygoteServer.runSelectLoop(), prepare IPC channel via socket, waiting for request
    5. in /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java --> runOnce() --> Zygote.forkAndSpecialize() --> handleChildProc(), fork a new process for application
    6. in /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java --> ZygoteInit.zygoteInit() --> ZygoteInit.nativeZygoteInit() --> Runtime.applicationInit() --> throw new Zygote.MethodAndArgsCaller(m, argv) --> caller.run()
    7. This throw gets caught in ZygoteInit.main(), which responds by invoking the exception's run() method. This arrangement clears up all the stack frames that were required in setting up the process. For application, this invoke ActivityThread class's main() method.
