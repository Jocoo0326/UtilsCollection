*** Binder理解
    - 优势有哪些？
      1. 性能角度：Binder数据拷贝只有一次，依靠内存映射mmap，将内核缓冲区映射到接收进程地址空间，性能仅次于共享内存
      2. 稳定性角度：基于C/S架构，结构清晰，稳定性好
    - 原理简述
      1. 通过ServiceManager获取代理对象，其实是以ServiceManagerProxy(BpBinder(0)) --> Binder driver --> ServiceManager --> handle --> BpBinder(handle)
      2. 调用服务接口其实是代理对象的mRemote(BpBinder) --> Binder driver --> system_server(服务实现者) --> 返回结果
    
*** ActivityManagerService的理解
    1. 负责activity、service、app进程控制
    2. 当需要在新的进程中启动的activity或者service时，AMS会创建新的app进程(startProcessLocked->Process.start-> ZygoteProcess.zygoteSendArgsAndGetResult(socket通信Zygote进程)->ZygoteInit.main->ZygoteServer.runSelectLoop-> ZygoteConnection.runOnce->Zygote.forkAndSpecialize->ZygoteInit.zygoteInit->ZygoteInit.nativeZygoteInit(init Binder)->RuntimeInit.invokeStaticMain)
    3. 创建app进程需完成两项工作(https://blog.csdn.net/luoshengyang/article/details/6747696)：
       - 初始化binder
       - 调用ActivityThread.main函数
*** Activity启动过程 
    1. Launcher调用Instrumentation.execStartActivity
    2. ActivityThread.handleLaunchActivity->performLaunchActivity，创建activity实例，->activity.attach，attach中创建PhoneWindow，->activity.onCreate->PhoneWindow.installDecor(setContentView)
    3. ->ActivityThread.handleResumeActivity->activity.onResume->WindowManagerGlobal.addView->创建ViewRootImpl->ViewRootImpl.setView->ViewRootImpl.requestLayout
*** Handler、Looper、MessageQueue
    1. Looper.loop()为何不会卡死主线程？
       - Looper.loop()->MessageQueue.next()->MessageQueue.nativePollOnce()->Looper::pollInner()(cpp)->epoll_wait
       - 利用了pipe/epoll机制，当MessageQueue.enqueMessage时若处于block状态会调用nativeWake->Looper::wake->write data to eventFd->epoll_wait unblocked
    2. MessageQueue.postSyncBarrier 当设置了障碍后，队列中的同步消息会停止执行，直到removeSyncBarrier被调用，默认情况下，消息都是同步的
*** Zygote进程启动过程以及创建新进程的过程
    1. init进程加载init.zygote32.rc文件，启动service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server, code base on android oreo 8.0.0_r4
    2. in /frameworks/base/cmds/app_process/app_main.cpp::main()  --> AndroidRuntime::start("com.android.internal.os.ZygoteInit", args, zygote)
    3. in /frameworks/base/core/jni/AndroidRuntime.cpp --> startVm() --> startReg()(注册jni方法) --> env->callStaticVoidMethod(), init android runtime, start java virtual machine and invoke ZygoteInit class's main method
    4. in /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java --> ZygoteServer.registerZygoteSocket() --> startSystemServer() --> ZygoteServer.runSelectLoop(), prepare IPC channel via socket, waiting for request
    5. in /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java --> runOnce() --> Zygote.forkAndSpecialize() --> handleChildProc(), fork a new process for application
       following steps are in child process
    6. in /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java --> ZygoteInit.zygoteInit() --> ZygoteInit.nativeZygoteInit()(registed in AndroidRuntime.cpp) --> AndroidRuntime::onZygoteInit() --> AppRuntime::onZygoteInit() --> ProcessState::startThreadPool()
    7. in /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java --> RuntimeInit.applicationInit() --> throw new Zygote.MethodAndArgsCaller(m, argv) --> caller.run()
    8. This throw gets caught in ZygoteInit.main(), which responds by invoking the exception's run() method. This arrangement clears up all the stack frames that were required in setting up the process. For application, this invoke ActivityThread class's main() method.
*** dagger2理解
**** dagger2是编译时依赖注入框架
**** 注入基本要素:
     1. 注入需求方，用@Inject标记field，field不能是private
     2. 注入提供方，@Inject标记构造函数，或者Module类(用@Module标记类)中用@Provides标记的方法(其返回值即为提供此对象的注入)
     3. 注入器，用@Component标记的接口，其中一般有一个inject(Target target)方法，表明Target类中需要注入用@Inject标记的field
**** AndroidInjection的理解
     1. 避免每个activity、fragment都要创建component, module, 注入的细节应该与被注入者保持透明, 被注入者中应该只有注入调用的模板方法，
	以减少对注入框架的耦合;
     2. 创建AppComponent;
	@Component(modules = {
          AllActivitiesModule.class
        })
        public interface AppComponent {
          void inject(App app);
        }
     3. application 实现 HasActivityInjector接口, 并注入DispatchingAndroidInjector<Activity>:
	public class App extends Application implements HasActivityInjector {
	  @Inject DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
	  
	  @Override public AndroidInjector<Activity> activityInjector() {
	    return dispatchingAndroidInjector;
          }
        }
     4. activity的onCreate方法中调用AndroidInjection.inject(this):
	public class BaseActivity extends AppCompactActivity {
	  @Override protected void onCreate(@Nullable Bundle savedInstanceState) {
	    AndroidInjection.inject(this);
	    super.onCreate(savedInstanceState)
          }
        }
     5. 创建AllActivitiesModule, 提供了activity和module的关联;
	@Module
        public abstract class AllActivitiesModule {

	  @ContributesAndroidInjector(modules = MainPageModule.class)
	  abstract MainPageActivity contributeMainPageActivityInjector();
        }

**** Singleton Scope实现是DoubleCheck.provider()
     1. module中provideInstanceXXX的创建过程是Provider<Module_ProvideInstanceXXXFactory> 
        or Provider<Module_ContributeMainPageActivityInjector.MainPageActivitySubcomponent.Builder>, 
        若@Singleton标记，则是DoubleCheck.provider(Module_ProvideInstanceFactory.create()), Provider提供了scope的功能;
     2. Module_ContributeMainPageActivityInjector.MainPageActivitySubcomponent提供创建module的功能, 并创建
	MainPageActivitySubcomponentImpl;
     3. MainPageActivitySubcomponentImpl实现了AndroidInjection<MainPageActivity>接口，提供inject逻辑;
