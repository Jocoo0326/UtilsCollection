*** Java平台的特点
**** Java平台的诞生解决了当时的一些痛点：
     - 对不同的平台，代码需要适配，然后编译对应的包
     - 内存的使用，分配和回收是一个非常棘手的问题，除了问题难于排查
     - 工程代码量快速增长，需要面向对象编程
**** JVM将各平台的硬件差异封装起来了，这是跨平台的重要基础
**** JVM引入内存管理，大大减轻程序员的负担
**** 生来就是面向对象语言，语法简单明了易于学习，避免了指针的使用，但有些冗余，不够精炼
**** 从编码->移植->编译->安装包(机器码)->执行的生产链发展为编码->编译->字节码->JVM->机器指令->执行的生产链中将与人参与的环节简单化，人性化，以提高整体链条的效率，是java成功的重要原因，也是很多技术发展变迁的源动力
*** Exception和Error的区别
**** Exception和Error都继承了Throwable类，只有Throwable才能被throw或者catch
**** Error是出现了严重的错误导致JVM处于非正常状态、不可恢复状态，常见的有OutOfMemoryError，NoClassDefFoundError等
**** Exception分为checked Exception和unchecked Exception(RuntimeException)，可检查异常必须显示捕获处理，使程序恢复运行流程，不检查异常即运行时异常，一般有程序员错误导致
**** try-with-resource可以用于关闭资源
**** try-catch-finally 应该不推诿和延时异常的处理，不生吞异常，finally用于关闭资源和释放锁等，finally是一定会执行的代码块，注意和return、continue、break跳转语句的使用，finally应避免覆盖try中返回值
*** 强引用、软引用、弱引用、幻象引用的区别
**** 主要体现在对象的可达性(reachable)状态和对垃圾回收的影响
**** 强引用，常见的对象引用，超出了作用域或者显示赋值为null，就可以被垃圾回收了
**** 软引用，当JVM内存不足时，会清除软引用指向的对象，常用于实现内存敏感的缓存，内存足够的时候缓存，不够的时候清除
**** 弱引用， 当GC触发时会立即被回收，仅提供一种访问对象的途径，异步操作callback宿主类常用，防止内存泄漏，同样也是缓存的实现选择
**** 幻象引用，不能通过它访问对象，get总是返回null，仅仅提供了一种确保对象被finalize以后，执行某种操作的机会，比如post-mortem清理机制
*** String、StringBuffer和StringBuilder的区别
**** String是final class，所有属性也是final的，属于典型的Immutable类，由于它的不可变性，类似拼接、裁剪等操作都会产生新的String对象
**** StringBuffer为了解决中间字符串的问题而生，使用append和add可以将字符串添加到已有序列的末尾或者指定位置，同时保证线程安全，通过将修改数据的方法加上synchronized实现，也会带来额外的性能开销
**** StringBuilder功能上和StringBuffer一样，但去掉了线程安全的部分，减少了性能开销
**** StringBuilder和StringBuffer都是继承自AbstractStringBuilder，区别就是修改数据的方法是否加了synchronized，数据是char[]，默认初始值是16，如果可以预计拼接的字符大小，应该提前指定，可以避免arraycopy
**** 字符串通常都会占用很多内存，所以引入了字符串常量池，创建一个字符串时先判断池中是否已有相同字符串对象，有则使用池中对象，没有则创建字符串并放入池中，注意一下区别：
     - String str = "abc";// 通过直接量赋值方式，放入常量池
     - String str1 = "abc";
     - String str2 = new String("abc");// 通过new方式赋值，不放入常量池
     - String str3 = new String("abcd");
     - System.out.println(str == str1);// true
     - System.out.println(str1 == "abc");// true
     - System.out.println(str2 == "abc");// false
     - System.out.println(str1 == str2);// false
     - System.out.println(str1.equals(str2));// true
     - System.out.println(str1 == str2.intern());// true
     - System.out.println(str2 == str2.intern());// false
     - System.out.println(str3 == str3.intern());// false
     - System.out.println(str1.hashCode() == str2.hashCode());// true
**** intern()会检查常量池中是否有equals的字符串，有则返回池中对象，没有则放入池中，并返回池中对象
**** JDK 8中字符串拼接操作会自动被javac转换成StringBuilder操作
     - String str = "a" + "b" + "c" + "d";
       // 字节码: ldc #2  // string abcd
     - String a = "a"; String str = a + "b" + "c" + "d";// 字节码:
       -  0: ldc           #2              // String a
       -  2: astore_1
       -  3: new           #3              // class java/lang/StringBuilder
       -  6: dup
       -  7: invokespecial #4              // Method java/lang/StringBuilder."<init>":()V
       - 10: aload_1
       - 11: invokespecial #5              // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       - 14: ldc           #6              // String bcd
       - 16: invokespecial #5              // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       - 19: invokespecial #7              // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
       - 22: astore_2
**** Java中的char是两个bytes大小
*** 动态代理的原理
**** 基于反射实现，反射是赋予程序运行时的自省能力(introspect)
     - 运行时获得一个对象的class
     - 运行时构造任意一个类的对象
     - 运行时获得一个类具有的成员和方法
     - 运行时调用一个对象的方法
**** 代理：将调用者与实现者解耦，对实现者透明，如日志，事物处理
**** 动态：代理的interface(方法集)动态变化，编码时指定方法实现规则，静态代理是编码时确定了代理方法
**** JDK proxy
     - 最小化依赖，减少依赖意味着简化开发和维护，JDK本身支持，可能比cglib更加可靠
     - 平滑进行JDK版本升级，而字节码类库通常需要进行更新以保证在新版Java上能够试用
     - 代码实现简单
**** cglib
     - 有时候代理目标不便实现额外的接口，限定调用者实现特定接口有些侵入性，cglib动态代理就没有这个限制
     - 只操作我们关心的类，而不必为其他相关类增加工作量
     - 高性能
*** Okio总结
**** 弥补了原生java.io的不足
     - 原生io大量使用装饰者模式，实现字符流的读取通常要包装很多层，涉及到很多类
     - 原生io的缓冲机制效率不高
**** io操作少不了缓冲机制，Okio提供了非常高效的缓冲机制Buffer，主要体现在Buffer到Buffer的读写尽可能的减少数据拷贝，而使用Segment的转移
**** 接口简单明了，一个类中提供了所有的操作方法，字符、字节读写通过方法区分(readByte, readString, etc)，读写操作粒度丰富，功能强大，调用简单，典型的例子：
     - try (BufferdSource bufferedSource = Okio.buffer(Okio.source(socket))) {
     -   String content = bufferedsource.readUTF8();
     - } catch (IOException e) {
     -   e.printStackTrace();
     - }
*** int和Integer有什么区别
**** int是原始类型，Integer是对象类型，Integer是int的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，如数学操作、int和String之间转换等
**** Integer可以根据上下文自动装箱和拆箱，实践中大部分数据操作都集中在有限的、较小的数值范围，所以Integer实现了值缓存，范围-128~127
**** 自动装箱算是一种语法糖，javac替我们自动把装箱装换成Integer.valueOf()(能够利用值缓存)，把拆箱转换成Integer.intValue()
**** Boolean缓存了Boolean.TRUE/FALSE，Short缓存了-128~127，Byte缓存了-128~127，Character缓存了'\u0000'~'\u007F'
**** 应避免不必要的装箱、拆箱行为
**** 缓存上限值可以根据需要调整，但下限固定是-128，JVM提供了参数设置：
     - -XX:AutoBoxCacheMax=N
**** value是private final int，保证基本信息的安全和并发编程中线程安全
**** 有趣的方法：
     - bitCount(int i)计算i二进制表示数中各位上1的个数，引用Hackers Delight中5-2算法:
     - i = i - ((i >>> 1) & 0x55555555); // 考虑将两位二进制数1的和表示出来，0x11 -> 0x10，i = 2a + b -> a + b = i - a = i - ((i >>> 1) & 0x01)
     - i = (i & 0x33333333) + ((i >>> 2) & 0x33333333); // 其他高位以此类推
     - i = (i + (i >>> 4)) & 0x0F0F0F0F;
     - i = i + (i >>> 8); // 最大值是32，只需考虑低6位
     - i = i + (i >>> 16);
     - return i & 0x3f;
*** Vector、ArrayList、LinkedList有何区别
**** Vector是Java早期提供的线程安全的动态数组，内部使用对象数组保存数据，具有自动扩容能力
**** ArrayList是应用更为广泛的动态数组实现，非线程安全，具有自动扩容能力，(初始大小是0，add一个元素后是10)，ArrayList扩容增加50%，Vector增加1倍
**** LinkedList是双向链表，不需要扩容，非线程安全
**** Vector和ArrayList作为动态数组，内部元素以数组形式顺序存储，所以非常适合随机访问的场合，除了尾部插入和删除元素，往往性能比较差，往中间插入一个元素，需要移动后续所有元素
**** LinkedList进行节点插入、删除却要高效的多，但是随机访问性能要比动态数组慢
*** HashTable、HashMap、TreeMap有何区别
**** HashTable是早期Java提供的哈希表实现，本身同步，不支持null键和值，initialCapacity=11，loadFactor=0.75，rehash之后newCapacity=(oldCapacity << 1) + 1，HashMap扩容后为原来2倍
**** HashMap是应用更为广泛的哈希表实现，行为大致和HashTable一致，主要区别在于HashMap非同步，支持null键和值，通常情况下，HashMap进行put和get可以达到常数时间的性能，所以它是绝大部分利用键值对存储场景的首选
**** HashMap的initialCapacity=16，loadFactor=0.75
**** TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，它的get、put、remove之类的操作都是O(logn)的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断
**** HashMap并发环境可能出现无限循环(桶内的链表变成了环形链表导致)
**** HashMap的性能表现非常依赖于哈希码的有效性，所以hashCode和equals的一些基本约定：
     - equals相等，hashCode一定要相等
     - 重写了hashCode也要重写equals
     - hashCode需要保持一致性，状态改变返回的哈希值仍然要一致
     - equals的对称、反射、传递等特性
**** HashMap的hash(Object key):
     - int h;
     - return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); // 将高位数据与低位数据合并，可以有效减少碰撞
**** ConcurrentHashMap基于lock实现锁分段技术，首先将数据分段，为每个段分配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，ConcurrentHashmap不仅保证了多线程环境下的数据访问安全性，性能上也有长足的提升
**** TODO 红黑树
*** 如何保证集合是线程安全的?ConcurrentHashMap如何实现高效的线程安全?
**** Java提供了不同层面的线程安全支持。传统集合框架内部，除了HashTable等同步容器，还提供了同步包装器(Synchronized Wrapper)，我们可以调用Collections工具类提供的包装方法，获取一个同步容器(i.e: Collections.synchronizedMap etc)，但非常粗粒度的方式(利用自身作mutex)，性能低下
**** 并发包提供的线程安全容器类
     - 各种并发容器，ConcurrentHashMap、CopyOnWriteArrayList
     - 各种线程安全队列(Queue/Deque)，ArrayBlockingQueue、SynchronousQueue
     - 各种有序容器的线程安全版本
**** 利用Unsafe的CAS(Compare and swap，CPU原子指令)实现无锁并发机制，线程更新时判断内存值是否与期望值一致，若是说明没有其他线程修改过，则更新新值，否则返回失败，重试进行，直至成功，最重要的是CAS是CPU原子指令，CAS操作通常配合while无限循环
*** Java提供了哪些io方式?NIO如何实现多路复用?
**** 传统java.io基于流模型实现，提供输入输出流，读取写入字节或字符流，属于同步阻塞io，缺点是io效率和扩展性存在局限性
**** Java1.4引入NIO框架，提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用、同步非阻塞IO程序，同时提供了更接近操作系统底层的高性能数据操作方式
**** Java7中，NIO进一步改进，也就是NIO2，引入了异步非阻塞IO，基于事件和回调机制
**** select模式是使用一个线程做监听，而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换上
**** Selector管理channel，channel关心一种事件，当channel接受到某事件时，selector.select()方法会被通知，进而处理IO操作
**** Linux上依赖epoll机制，windows依赖iocp
*** ThreadPoolExecutor的理解
**** 参数意义:
     - corePoolSize: 核心Worker线程的数量
     - maximumPoolSize: 线程池最大Worker线程的数量
     - keepAliveTime: Worker线程结束之前的空闲时间
     - unit: 时间的单位
     - workQueue: 存放Runnable的阻塞队列
     - threadFactory: 创建线程的工厂
     - handler: 不能接受Runnable时的拒绝策略
**** 执行规则:
     1. 若currentThreadCount < corePoolSize 创建core线程，core线程会立即执行；
     2. 若currentThreadCount >= corePoolSize 放入阻塞队列；
     3. 队列已满后，若currentThreadCount < maximumPoolSize 创建新的线程。
**** 为什么能够复用线程?以及空闲超时的原理?
     提交任务Runnable后，线程池会创建一个Worker线程，线程中while循环执行任务，线程执行完当前任务后，会从等待队列里获取一个任务并执行，如此就避免了重复创建线程，实际是一个线程执行多个runnable， 线程的超时由队列的超时操作实现。
*** Synchronized和ReentrantLock有什么区别？
    1. Synchronized是Java内建同步机制，提供了互斥的语义和可见性，一个线程获取锁，其他试图获取锁的线程只能等待或阻塞
    2. ReentrantLock是再入锁，语义和Synchronized基本相同，通过调用lock方法获取锁，书写灵活，一般配合try-catch-finally，并在finally中调用unlock释放锁，当线程已获取了锁，lock方法会立即返回
    3. Reentrantlock提供更细粒度的同步操作，可以提供公平性(等待时间长的线程优先获取锁)，定义条件
    4. 通过lock.isHeldByCurrentThread可以判断当前线程是否拥有这个锁
