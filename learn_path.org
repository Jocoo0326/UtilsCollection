* crash
*** 进程crash时会发送signal（SIGSEGV，SIGART etc），提前注册sigaction处理目标signal，然后clone进程，使用ptrace syscall获
取进程mem reg信息，同时获取procfs信息得到thread stacktrace
*** breakpad   ---> crashDump --> addr2line
*** fork和pthread_create都使用clone syscall实现，可以指定共享哪些数据区域

* Finalizer
*** object.finalize() run in FinalizerDaemon thread
*** FinalizerWatchdogDaemon thread 监控FinalizerDaemon thread的执行，若FinalizerDaemon执行某个object的finalize方法超过10s，
则发出SIGQUIT signal
*** finalize timeout 可以通过反射停止FinalizerWatchdogDaemon，Android P限制反射调用失效

* generate code at runtime
*** u1 code[PAGE_SIZE]; mprotect(code, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC); memcpy(code, "\xC3", 1);
* RecyclerView
*** Recycler.tryGetViewHolderForPositionByDeadline缓存逻辑: 
# 根据position查找mAttachedScrap-->mHiddenViews-->mCachedViews，
# 根据type查找mAttachedScrap-->mCachedViews
# if mViewCacheExtension != null, 通过mViewCacheExtension查找
# mRecyclerPool中查找
# mAdapter.createViewHolder

* android gradle plugin
*** 方法的最后一个参数是闭包时可以将{}移到()外，同时()可以省略，所以常见的android {...}
*** android包含属性：compileSdkVersion、buildToolsVersion、defaultConfig、buildTypes、signingConfigs、lintOptions、
compileOptions etc
*** defaultConfig是默认的productFlavor类型，包含applicationId、minSdkVersion、versionCode、versionName、
testInstrumentationRunner、ndk etc
*** buildType属性：applicationSuffix、debuggable、jniDebuggable、minifyEnabled、multiDexEnabled、proguardFile、shrinkResources、
signingConfig、zipAlignEnabled
*** variant 是productFlavors和buildTypes组合产物，variant有applicationVariants、libraryVariants、testVariants
*** 使用exec可以执行命令行操作
*** 可以通过环境变量System.getenv()获取签名信息，从而隐藏签名信息
*** manifestPlaceHolders buildConfigField resValue
* Java Thread start
*** android-source/art/runtime/thread_state.h
enum ThreadState {
  //                                   Thread.State   JDWP state
  kTerminated = 66,                 // TERMINATED     TS_ZOMBIE    Thread.run has returned, but Thread* still around
  kRunnable,                        // RUNNABLE       TS_RUNNING   runnable
  kTimedWaiting,                    // TIMED_WAITING  TS_WAIT      in Object.wait() with a timeout
  kSleeping,                        // TIMED_WAITING  TS_SLEEPING  in Thread.sleep()
  kBlocked,                         // BLOCKED        TS_MONITOR   blocked on a monitor
  kWaiting,                         // WAITING        TS_WAIT      in Object.wait()
  kWaitingForLockInflation,         // WAITING        TS_WAIT      blocked inflating a thin-lock
  kWaitingForTaskProcessor,         // WAITING        TS_WAIT      blocked waiting for taskProcessor
  kWaitingForGcToComplete,          // WAITING        TS_WAIT      blocked waiting for GC
  kWaitingForCheckPointsToRun,      // WAITING        TS_WAIT      GC waiting for checkpoints to run
  kWaitingPerformingGc,             // WAITING        TS_WAIT      performing GC
  kWaitingForDebuggerSend,          // WAITING        TS_WAIT      blocked waiting for events to be sent
  kWaitingForDebuggerToAttach,      // WAITING        TS_WAIT      blocked waiting for debugger to attach
  kWaitingInMainDebuggerLoop,       // WAITING        TS_WAIT      blocking/reading/processing debugger events
  kWaitingForDebuggerSuspension,    // WAITING        TS_WAIT      waiting for debugger suspend all
  kWaitingForJniOnLoad,             // WAITING        TS_WAIT      waiting for execution of dlopen and JNI on load code
  kWaitingForSignalCatcherOutput,   // WAITING        TS_WAIT      waiting for signal catcher IO to complete
  kWaitingInMainSignalCatcherLoop,  // WAITING        TS_WAIT      blocking/reading/processing signals
  kWaitingForDeoptimization,        // WAITING        TS_WAIT      waiting for deoptimization suspend all
  kWaitingForMethodTracingStart,    // WAITING        TS_WAIT      waiting for method tracing to start
  kWaitingForVisitObjects,          // WAITING        TS_WAIT      waiting for visiting objects
  kWaitingForGetObjectsAllocated,   // WAITING        TS_WAIT      waiting for getting the number of allocated objects
  kWaitingWeakGcRootRead,           // WAITING        TS_WAIT      waiting on the GC to read a weak root
  kWaitingForGcThreadFlip,          // WAITING        TS_WAIT      waiting on the GC thread flip (CC collector) to finish
  kStarting,                        // NEW            TS_WAIT      native thread started, not yet ready to run managed code
  kNative,                          // RUNNABLE       TS_RUNNING   running in a JNI native method
  kSuspended,                       // RUNNABLE       TS_RUNNING   suspended by GC or debugger
};
*** android-source/art/runtime/native/java_lang_Thread.cc
Thread.start()-->nativeCreate()-->Thread.CreateNativeThread()-->JNIEnvExt::Creat()-->pthread_create()-->child_thread invoke java Thread.run() method
*** JNIEnv implemented in android-source/art/runtime/jni_internal.cc
* x86_64
*** 函数传参寄存器顺序rdi, rsi, rdx, rcx, r8, r9，超过6个则压栈
*** callq会push %rip(return address aka.下一条指令)
*** %rax保存返回值
* gdb
*** $sp $pc $fp 别名适用所有平台
*** x/i $pc 当前指令
*** x/32x $sp 显示stack内存信息
*** objdump -dS elf显示汇编
*** disas/m 反汇编code
* lag analyze tool
*** TraceView
  - Debug.startMethodTracing("sample") Debug.startMethodTracingSampling() Debug.stopMethodTracing()
*** Systrace
  - ./systrace.py sched freq idle am wm gfx view sync binder_driver irq workq input -b 96000
  - java framework: Trace.traceBegin(long traceTag, String methodName) Trace.traceEnd(long traceTag)
  - app: Trace.beginSection(String sectionName) Trace.endSection()
  - native: ATRACE_CALL();
*** 获取GC统计信息
  - // GC 使用的总耗时，单位是毫秒
    Debug.getRuntimeStat("art.gc.gc-time");
    // 阻塞式 GC 的总耗时
    Debug.getRuntimeStat("art.gc.blocking-gc-time");

* C++ mangle/demangle tool
*** c++filt -n _ZN7android6Tracer12sEnabledTagsE
* Hook
** inline hook 
*** Substrate
**** MSHookFunction(void *symbol, void *replace, void **result)
 - 作用：symbol：原函数地址，replace：hook函数地址，result：返回动态生成的代替原函数的指针，用于在hook函数中调用原来的逻辑
 - 替换symbol的前几个指令，将其跳转到replace的首地址，replace中调用*result(mmap新的buffer，保存old function头部被替换的字节，尾部跳转到原函数未被替换字节的首地址)
** PLT/GOT hook
*** PLT(procedure linkage table) GOT(global offset table)
*** example:
callq <printf@PLT> 查找GOT中相应记录，若没有加载printf地址，加载so库，修改GOT中printf记录地址为真实地址，后续调用直接调用GOT中真实地址
*** dl_iterate_phdr
walk through list of shared objects
*** facebook profilo iqiyi xHook
* vcpkg
*** visual stduio管理第三方libs
* unit test
*** 安全的重构代码
*** cmake && google test
* ASM
** event-based and tree-based api
** Parsing Generating Transforming class
** ClassReader ClassVisitor ClassWriter
** ClassWriter implemented ClassVisitor
*** visitXXX方法调用时会写入字节码数据
*** toByteArray返回记录的字节码数据
** ASMifier class -> java (generating class bytecode with ASM ClassWriter)
* clojure
** cider
*** M-x cider-jack-in C-c M-j
* FPS tracer
** Choreographer.FrameCallback
* tracing activity startup
** reflect android.app.ActivityThread -> sCurrentActivityThread -> mH -> mCallback(hook with new one)
* ClassLoader
** locate or generate data that constitutes a definition for the class
** Class object contains a reference to the ClassLoader that defined it
** 数组对象的Class由JVM创建，非ClassLoader，且与其元素类型Class的ClassLoader相同；基本类型数据数组的Class无ClassLoader
** 代理加载机制，即先向父ClassLoader请求加载类，未找到则自己加载
** defineClass 将字节数组转换成Class对象
* gradle
** gradle init --type java-application
** gradle jar
#+begin_src groovy
  jar {
      manifest {
          attributes("Main-Class": "App")
      }
  }

  task uberJar(type: Jar) {
      classifier = "all"
      from sourceSets.main.output
      manifest {
          attributes("Main-Class": "App")
      }

      dependsOn configurations.runtimeClasspath
      from {
          configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
      }

      with jar
  }
#+end_src

